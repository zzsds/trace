package queue

import (
	"encoding/json"
	"os"
	"os/signal"
	"time"

	"github.com/google/uuid"
)

// Server 对外服务接口
type Server interface {
	Len() int
	Name() string
	Front() *Node
	Back() *Node
	Get(index int) *Data
	Push(*Data) *Node
	Unshift(*Data) *Node
	Shift() *Node
	Pop() *Node
	InsertBefore(*Data, *Node) *Node
	InsertAfter(*Data, *Node) *Node
	Header() *Node
	WriteBuffer(Data) chan Data
	Buffer() <-chan Data
	Remove(*Node) interface{}
	Listen(Call) error
	List() []Data
	Loop(Call) error
}

// NodeServer ...
type NodeServer interface {
	Current() *Node
	Next() *Node
	Prev() *Node
	Data() *Data
}

// Node ...
type Node struct {
	queue      *queue
	prev, next *Node
	data       *Data
}

// Call ...
type Call func(*Node) error

// NewNode ...
func NewNode(data *Data) *Node {
	node := new(Node).init()
	node.data = data
	return node
}

// Next returns the next list Node or nil.
func (e *Node) init() *Node {
	e.data = nil
	e.prev = nil
	e.next = nil
	e.queue = nil
	return e
}

// Current ...
func (e *Node) Current() *Node {
	return e
}

// Next returns the next list Node or nil.
func (e *Node) Next() *Node {
	if p := e.next; e.queue != nil && p != &e.queue.root {
		return p
	}
	return nil
}

// Prev returns the previous list Node or nil.
func (e *Node) Prev() *Node {
	if p := e.prev; e.queue != nil && p != &e.queue.root {
		return p
	}
	return nil
}

// Data ...
func (e *Node) Data() *Data {
	return e.data
}

// Queue ...
type Queue queue

// queue ...
type queue struct {
	opts options
	len  int
	root Node
}

// NewQueue new queue
func NewQueue(opts ...Option) Server {
	queue := new(queue).Init()
	queue.opts = newOptions(opts...)
	return queue
}

// Init 初始化队列
func (h *queue) Init() *queue {
	h.root.next = &h.root
	h.root.prev = &h.root
	h.len = 0
	return h
}

// Len 长度
func (h *queue) Len() int { return h.len }

// Name 名称
func (h *queue) Name() string {
	return h.opts.name
}

// lazyInit lazily initializes a zero List value.
func (h *queue) lazyInit() {
	if h.root.next == nil {
		h.Init()
	}
}

// insert inserts e after at, increments l.len, and returns e.
func (h *queue) insert(e, at *Node) *Node {
	e.prev = at
	e.next = at.next
	e.prev.next = e
	e.next.prev = e
	e.queue = h
	h.len++
	return e
}

// insertValue is a convenience wrapper for insert(&Element{Value: v}, at).
func (h *queue) insertValue(v *Data, at *Node) *Node {
	return h.insert(NewNode(v), at)
}

// remove removes e from its list, decrements l.len, and returns e.
func (h *queue) remove(node *Node) *Node {
	node.prev.next = node.next
	node.next.prev = node.prev
	node.next = nil // avoid memory leaks
	node.prev = nil // avoid memory leaks
	node.queue = nil
	h.len--
	return node
}

// move moves e to next to at and returns e.
func (h *queue) move(e, at *Node) *Node {
	if e == at {
		return e
	}
	e.prev.next = e.next
	e.next.prev = e.prev

	e.prev = at
	e.next = at.next
	e.prev.next = e
	e.next.prev = e

	return e
}

// Front 获取下一个
func (h *queue) Front() *Node {
	if h.len == 0 {
		return nil
	}
	return h.root.next
}

// Back returns the last element of list l or nil if the list is empty.
func (h *queue) Back() *Node {
	if h.len == 0 {
		return nil
	}
	return h.root.prev
}

// Header 头部
func (h *queue) Header() *Node {
	return &h.root
}

// WriteBuffer 写入数据到缓冲
func (h *queue) WriteBuffer(v Data) chan Data {
	h.opts.buffer <- v
	return h.opts.buffer
}

// Buffer 获取缓冲
func (h *queue) Buffer() <-chan Data {
	return h.opts.buffer
}

// InsertBefore 之前插入
func (h *queue) InsertBefore(v *Data, node *Node) *Node {
	if node.queue != h {
		return nil
	}
	// see comment in List.Remove about initialization of l
	return h.insertValue(v, node.prev)
}

// InsertAfter 之后插入
func (h *queue) InsertAfter(v *Data, node *Node) *Node {
	if node.queue != h {
		return nil
	}
	// see comment in List.Remove about initialization of l
	return h.insertValue(v, node)
}

// Remove 删除
func (h *queue) Remove(node *Node) interface{} {
	h.opts.mutex.Lock()
	defer h.opts.mutex.Unlock()
	if node.queue == h {
		// if e.list == l, l must have been initialized when e was inserted
		// in l or l == nil (e is a zero Element) and l.remove will crash
		h.remove(node)
	}
	return node.Data().Value
}

// Loop 单次循环
func (h *queue) Loop(call Call) error {
	for node := h.Front(); node != nil; node = node.Next() {
		if err := call(node); err != nil {
			break
		}
	}
	return nil
}

// Listen 持续监听
func (h *queue) Listen(call Call) error {
	go func() {
		for {
			for node := h.Front(); node != nil; node = node.Next() {
				if err := call(node); err != nil {
					break
				}
			}
		}
	}()

	ch := make(chan os.Signal, 1)
	if h.opts.signal {
		signal.Notify(ch, os.Kill)
	}

	// wait on kill signal
	<-ch
	return nil
}

// Get 根据索引查询
func (h *queue) Get(index int) *Data {
	if h.len == 0 || h.len < int(index) {
		return nil
	}
	i := 0
	for node := h.Front(); node != nil; node = node.Next() {
		if i == index {
			return node.data
		}
		i++
	}
	return nil
}

// Unshift 开头插入
func (h *queue) Unshift(v *Data) *Node {
	h.lazyInit()
	return h.insertValue(v, &h.root)
}

// Push 压入末尾
func (h *queue) Push(v *Data) *Node {
	h.lazyInit()
	return h.insertValue(v, h.root.prev)
}

// Shift 移出开始第一个
func (h *queue) Shift() *Node {
	if h.len <= 0 {
		return nil
	}
	h.opts.mutex.Lock()
	defer h.opts.mutex.Unlock()
	return h.remove(&h.root)
}

// Pop 弹出结尾最后一个
func (h *queue) Pop() *Node {
	if h.len <= 0 {
		return nil
	}
	h.opts.mutex.Lock()
	defer h.opts.mutex.Unlock()

	return h.remove(h.Back())
}

// PushFrontList inserts a copy of another list at the front of list l.
// The lists l and other may be the same. They must not be nil.
func (h *queue) PushFrontList(other *queue) {
	h.lazyInit()
	for i, e := other.Len(), other.Back(); i > 0; i, e = i-1, e.Prev() {
		h.insertValue(e.data, &h.root)
	}
}

// Unique 去重
func (h *queue) Unique() error {
	return nil
}

// Replace 替换
func (h *queue) Replace(old *Node, new *Node) error {
	return nil
}

func (h *queue) List() []Data {
	list := make([]Data, 0, h.len)
	for node := h.Front(); node != nil; node = node.Next() {
		list = append(list, *node.data)
	}
	return list
}

// Data ...
type Data struct {
	opts     options
	UUID     string
	CreateAt time.Time
	ExpireAt *time.Time
	Value    interface{}
}

// DataFunc ...
type DataFunc func(*Data) error

// NewData ...
func NewData(v interface{}) *Data {
	uuid, _ := uuid.NewUUID()
	return &Data{
		opts:     newOptions(Name("Default")),
		UUID:     uuid.String(),
		CreateAt: time.Now(),
		Value:    v,
	}
}

// NewExpireData ...
func NewExpireData(Value interface{}, expire time.Time) *Data {
	uuid, _ := uuid.NewUUID()
	return &Data{
		opts:     newOptions(Name("Default")),
		UUID:     uuid.String(),
		CreateAt: time.Now(),
		Value:    Value,
		ExpireAt: &expire,
	}
}

// Update ...
func (h *Data) Update(data *Data) error {
	h.opts.mutex.Lock()
	defer h.opts.mutex.Unlock()
	h = data
	return nil
}

// UpdateValue ...
func (h *Data) UpdateValue(v interface{}) error {
	h.opts.mutex.Lock()
	defer h.opts.mutex.Unlock()
	h.Value = v
	return nil
}

// ParseValue ...
func (h *Data) ParseValue(v interface{}) error {
	b, err := json.Marshal(h.Value)
	if err != nil {
		return err
	}
	return json.Unmarshal(b, v)
}
